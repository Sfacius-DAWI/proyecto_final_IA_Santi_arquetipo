---
description: 
globs: *.ts
alwaysApply: false
---
# Mejores Pr√°cticas para TypeScript

## üéØ Visi√≥n General

Este conjunto de reglas define las mejores pr√°cticas para escribir c√≥digo TypeScript mantenible, seguro y eficiente.

## üö® REGLAS CR√çTICAS

1. Tipos Expl√≠citos
- SIEMPRE define tipos expl√≠citos para par√°metros de funciones
- SIEMPRE define tipos de retorno para funciones p√∫blicas
- NUNCA uses `any` sin una justificaci√≥n documentada

```typescript
// ‚úÖ CORRECTO
function sumarNumeros(a: number, b: number): number {
    return a + b;
}

// ‚ùå INCORRECTO
function sumarNumeros(a, b) {
    return a + b;
}
```

2. Interfaces vs Types
- USA interfaces para definir objetos y clases
- USA types para uniones, intersecciones y utilidades
- EVITA mezclar interfaces y types sin necesidad

```typescript
// ‚úÖ CORRECTO
interface Usuario {
    id: number;
    nombre: string;
}

type ResultadoOperacion = "exito" | "error";

// ‚ùå INCORRECTO
type Usuario = {
    id: number;
    nombre: string;
}
```

3. Null y Undefined
- USA undefined para valores opcionales
- EVITA null excepto cuando sea necesario para APIs externas
- SIEMPRE usa el operador de optional chaining (?.)

```typescript
// ‚úÖ CORRECTO
interface Configuracion {
    tema?: string;
    idioma: string;
}

// ‚ùå INCORRECTO
interface Configuracion {
    tema: string | null;
    idioma: string;
}
```

## üìù Convenciones de Nomenclatura

1. Nombres de Interfaces
- USAR PascalCase
- PREFIJO 'I' opcional pero consistente en todo el proyecto

```typescript
// ‚úÖ CORRECTO
interface UserProfile {}
// o
interface IUserProfile {}

// ‚ùå INCORRECTO
interface userProfile {}
```

2. Tipos Gen√©ricos
- USAR T, K, V para tipos simples
- USAR nombres descriptivos para tipos complejos

```typescript
// ‚úÖ CORRECTO
function obtenerPrimero<T>(array: T[]): T {}
interface Respuesta<TData> {}

// ‚ùå INCORRECTO
function obtenerPrimero<Tipo>(array: Tipo[]): Tipo {}
```

## üõ°Ô∏è Seguridad de Tipos

1. Strict Mode
- SIEMPRE habilitar `strict: true` en tsconfig.json
- NUNCA deshabilitar comprobaciones estrictas sin justificaci√≥n

2. Aserciones de Tipo
- EVITAR aserciones de tipo (as) cuando sea posible
- USAR guardas de tipo en su lugar

```typescript
// ‚úÖ CORRECTO
function esString(valor: unknown): valor is string {
    return typeof valor === 'string';
}

// ‚ùå INCORRECTO
const valor = dato as string;
```

## üèóÔ∏è Arquitectura y Organizaci√≥n

1. M√≥dulos
- USAR imports/exports con nombre en lugar de exports default
- ORGANIZAR imports por grupos (externos, internos, tipos)

```typescript
// ‚úÖ CORRECTO
import { Component } from 'react';
import { Usuario } from './tipos';
import { formatearFecha } from './utilidades';

// ‚ùå INCORRECTO
import React from 'react';
import formatearFecha from './utilidades';
```

2. Barrel Exports
- USAR barrel exports (index.ts) para m√≥dulos relacionados
- MANTENER la estructura de carpetas plana cuando sea posible

## üß™ Testing

1. Tipos en Tests
- MANTENER el mismo nivel de tipado en c√≥digo de prueba
- USAR tipos mock espec√≠ficos para pruebas

```typescript
// ‚úÖ CORRECTO
interface MockUsuario extends Usuario {
    esMock: true;
}

// ‚ùå INCORRECTO
const mockUsuario: any = { /* ... */ };
```

## üìö Documentaci√≥n

1. JSDoc
- DOCUMENTAR funciones p√∫blicas con JSDoc
- INCLUIR ejemplos de uso cuando sea apropiado

```typescript
// ‚úÖ CORRECTO
/**
 * Calcula el total de una lista de productos
 * @param productos - Lista de productos con precios
 * @returns El total calculado
 * @throws Si la lista est√° vac√≠a
 */
function calcularTotal(productos: Producto[]): number
```

## üîÑ Control de Versiones

1. Archivos de Declaraci√≥n
- MANTENER archivos .d.ts separados para declaraciones globales
- EVITAR modificar tipos de bibliotecas directamente
